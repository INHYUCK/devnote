# CPP

---
### PART 01 C++로의 전환
---

 1. C언어 기반의 C++ 1
	* 01-1 printf와 scanf를 대신하는 입출력 방식
		<pre>  헤더파일의 선언 #include <iostream>
		출력의 기본구성 std::out<<"출력대상1"<<"출력대상";
		개행의 진행 std::endl;
		c언어에서와 달리 출력대상에 따라 서식지정을 달리 할 필요가 없다.
		
		입력의 기본구성 std::cin>>변수
		변수의 선언위치 함수의 중간 부분에서도 선언이 가능하다.
		출력에서와 마찬가지로 별도의 서식지정이 불필요 하다.
		std::cin>>val1>>val2; std::cin을 통해서 입력되는 데이터의 구분은 스페이스 바, 엔터, 탭과같은 공백을 통해서 이뤄진다. </pre>
	
	* 01-2 함수 오버로딩(Function Overloading)
		<pre> C++은 함수호출 시 '함수의 이름'과 '전달되는 인자의 정보'를 동시에 참조하여 호출할 함수를 결정한다. 따라서 매개변수의 선언이 다르다면 동일한 함수의 정의가 가능하다. 이러한 함수정의를 가리켜 '함수 오버로딩(Function Overloading)'이라 한다.
		'반환형'의 차이는 함수 오버로딩의 조건을 만족시키지 않는다. </pre>
	* 01-3 매개변수의 디폴트 값(Default Value)
		<pre> 전달되는 인자가 왼쪽부터 채워지므로, 오른쪽이 빈 상태로 왼쪽의 매개변수에만 일부 채워진 디폴트 값은 의미를 갖지 못한다. 따라서 컴파일 에러를 일으킨다. </pre>
		
	* 01-4 인라인(inline) 함수
		<pre>  매크로 함수 : 컴파일 전 코드 자체를 치환한다. 자료형에 독립적이다. 
		함수호출 : 실행시 해당 해당 함수 메모리 영역에 접근하여 코드 실행 후 리턴한다.
		인라인함수 : 일반함수처럼 보이지만 컴파일 후에는 매크로함수처럼 해당 함수내용으로 치환된다. 매크로 함수의 장점은 취하고 단점은 보완. 함수가 인라인화 되어 성능의 향상으로 이어질 수 있지만, 함수의 정의방식이 일반함수에 비해서 복잡하다. 따라서 복잡한 함수의 정의에는 한계가 있다.

		Call-by-reference vs. call-by-value
		Call-by-Value는 함수에 인자를 변수에 대입된 값 복사해서 전달해주는것을 의미한다. 따라서 원래 데이터에 영향을 미치지 않는다.
		Call-by-reference는 함수에 인자를 값에대한 참조, 메모리 주소를 담고있는 변수를 넘겨준다. 참조를 넘기다보니 참조가 가리키는 값을 복사하지는 않는다. 따라서 원래데이터에 영향을 미칠 수 있다.</pre>
	* 01-5 이름공간(namespace)에 대한 소개
		<pre>  존재한는 이름공간이 다르면 동일한 이름의 함수 및 변수를 선언하는 것이 가능하다. 
		프로젝트의 진행에 있어서 발생할 수 있는 이름의 충돌을 막을 목적으로 존재하는 것이 이름공간이다.</pre>

2. C언어 기반의 C++ 2
	* 02-1 Chapter 02의 시작에 앞서
		<pre>키워드 const
		const int num=10; //변수 num을 상수화
		const int * ptr1 = &val1; //포인터 ptr1을 이용해서 val1의 값을 변경할 수 없음.
		int * const ptr2 = &val2; //포인터 ptr2가 상수화
		const int * const ptr3 = val3; //포인터 ptr3이 상수화 되었으며 ptr3을 통해 val3의 값을 변경할 수 없음.</pre>
		<pre>실행중인 프로그램의 메모리공간
		데이터 - 전역변수가 저장되는 영역
		스택 - 지역변수 및 매개변수가 저장되는 영역
		힙 - malloc 함수호출에 의해 프로그램이 실행되는 과정에서 동적으로 할당이 이뤄지는 영역</pre>
	* 02-2 새로운 자료형 bool	
		<pre>true는 참을 의미하는 1byte데이터. false는 거짓을 의미하는 1byte데이터. 
		정수가 와야할 위치에 오게 되면 각각 1, 0으로 변환이 된다.</pre>
	* 02-3 참조자(Reference)의 이해
		<pre>참조자는 기존에 선언된 변수에 붙이는 '별칭'이다.
		*상수 대상으로는 참조자 선언이 불가능.
		*참조자는 생성과 동시에 누군가를 참조해야 한다.
		*포인터처럼 NULL로 초기화하는 것도 불가능하다.
		=>참조자는 선언과 동시에 누군가를 참조해야 하는데, 그 참조의 대상은 기본적으로 변수가 되어야한다.</pre>
	* 02-4 참조자(Reference)와 함수
		<pre></pre>
	* 02-5 malloc & free를 대신하는 new & delete
		<pre></pre>
	* 02-6 C++에서 C언어의 표준함수 호출하기

---
### PART 02 객체지향의 도입
---

3. 클래스의 기본
	* 03-1 C++에서의 구조체
	* 03-2 클래스(Class)와 객체(Object)
	* 03-3 객체지향 프로그래밍의 이해
	
4. 클래스의 완성
	* 04-1 정보은닉(Information Hiding)
	* 04-2 캡슐화(Encapsulation)
	* 04-3 생성자(Constructor)와 소멸자(Destructor)
	* 04-4 클래스와 배열 그리고 this 포인터
	
5. 복사 생성자(Copy Constructor)
	* 05-1 '복사 생성자'와의 첫 만남
	* 05-2 '깊은 복사'와 '얕은 복사'
	* 05-3 복사 생성자의 호출시점
	
6. friend와 static 그리고 const
	* 06-1 const와 관련해서 아직 못다한 이야기
	* 06-2 클래스와 함수에 대한 friend 선언
	* 06-3 C++에서의 static
	
---
### PART 03 객체지향의 전개
---

7. 상속(Inheritance)의 이해
	* 07-1 상속에 들어가기에 앞서
	* 07-2 상속의 문법적인 이해
	* 07-3 protected 선언과 세 가지 형태의 상속
	* 07-4 상속을 위한 조건
	

  











### by 윤성우 열혈 C++프로그래밍
